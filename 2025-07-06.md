### [一个好问题（A Good Problem）](https://codeforces.com/contest/2119/problem/C)

**时间限制：** 2 s
**内存限制：** 256 MB

**输入：** 标准输入
**输出：** 标准输出



你被给定了四个正整数 $n$，$l$，$r$，$k$。你需要找出一个按 **字典序**$\large^{\text{∗}}$ 最小的长度为 $n$ 的数组 $a$，数组由整数构成，满足以下条件：

- 对于所有 $1 \leq i \leq n$，有 $l \leq a_i \leq r$。
- 满足：$a_1\ \&\ a_2\ \& \ldots \&\ a_n = a_1 \oplus a_2 \oplus \ldots \oplus a_n$，其中 $\&$ 表示[按位与运算（bitwise AND）](https://en.wikipedia.org/wiki/Bitwise_operation#AND)，$\oplus$ 表示[按位异或运算（bitwise XOR）](https://en.wikipedia.org/wiki/Bitwise_operation#XOR)。

如果不存在这样的数组，输出 `-1`。否则，由于整个数组可能过大，**只需输出 $a_k$ 的值**。



$\large^{\text{∗}}$一个数组 $a$ 被认为按字典序小于另一个数组 $b$，当且仅当以下情况之一成立：

- $a$ 是 $b$ 的前缀，但 $a \ne b$；或
- 在 $a$ 和 $b$ 第一个不同的位置上，$a$ 的对应元素小于 $b$ 的对应元素。







### 输入

每个测试包含若干个用例。

第一行包含一个整数 $t$（$1 \le t \le 10^4$），表示测试用例的数量。

接下来的 $t$ 行，每行包含四个正整数 $n$，$l$，$r$，$k$（$1 \le k \le n \le 10^{18}$，$1 \le l \le r \le 10^{18}$）。





### 输出

对于每个测试用例，输出一行答案：字典序最小合法数组的第 $k$ 个元素，或是 `-1` 表示不存在。





### 样例

**样例输入：**

```
9
1 4 4 1
3 1 3 3
4 6 9 2
4 6 9 3
4 6 7 4
2 5 5 1
2 3 6 2
999999999999999999 1000000000000000000 1000000000000000000 999999999999999999
1000000000000000000 1 999999999999999999 1000000000000000000
```



**样例输出：**

```
4
1
6
8
-1
-1
-1
1000000000000000000
2
```





### 注意

在第一个测试案例中，数组 $a=[4]$。可以证明不存在满足上述要求并且具有更小字典顺序的数组。

在第二个测试案例中，数组 $a=[1$，$1$，$1]$。可以证明不存在满足上述要求并且具有更小字典顺序的数组。

在第三个测试案例和第四个测试案例中，数组 $a=[6$，$6$，$8$，$8]$。可以证明不存在满足上述要求并且具有更小字典顺序的数组。

在第五个测试案例和第六个测试案例中，可以证明不存在满足上述要求的数组。





### 题解

* 当 $n$ 为奇数时，可以令所有元素都为 $l$。因为奇数个相同数异或仍为该数，按位与也为该数，所以满足条件。

* 当 $n$ 为偶数时，为了获得字典序最小的数组，前 $n-2$ 个位置尽量填 $l$。此时这部分的异或为 $0$，按位与仍为 $l$。

    * 设 $t$ 为大于 $l$ 的最小的 $2$ 的幂，若 $t \leq r$，则后两个数填 $t$，计算后的结果等号两边都为 $0$，满足条件。

        末尾两个 $t$ 的异或为 $0$，与前 $n-2$ 个 $l$ 异或后仍为 $0$；而 $l\ \&\ t = 0$，因为 $l$ 与 $t$ 没有公共的二进制位为 1，故整体按位与也是 $0$。

    * 但当 $n = 2$ 或 $t > r$ 时无法构造出合法数组，应输出 `-1`。



```cpp
void solve()
{
	int n, l, r, k;
	cin >> n >> l >> r >> k;
	if (n % 2)
		cout << l << endl;
	else
	{
		int t = 1;
		while (t <= l) t <<= 1;
		if (t > r || n == 2)
			cout << -1 << endl;
		else if (n - k < 2)
			cout << t << endl;
		else
			cout << l << endl;
	}
}
```