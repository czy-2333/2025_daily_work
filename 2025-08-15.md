## [双生双宿之错（The Blunder of Twin Destinies）](https://ac.nowcoder.com/acm/contest/95323/E)

**时间限制：** 1 s
**内存限制：** 256 MB



小红定义一个数组是 **双生数组**，当且仅当该数组大小为偶数，数组的元素种类恰好为 $2$ 种，且这两种元素的出现次数相同。例如 $\{1$，$1$，$4$，$4$，$1$，$4\}$ 是双生数组。  

现在小红拿到了一个长度为偶数的数组，她可以进行若干次操作，每次操作将选择一个元素，使其加 $1$ 或者减 $1$。小红希望你计算将该数组变成双生数组的最小操作次数。







### 输入

每个测试文件均包含多组测试数据。第一行输入一个整数 $t$（$1 \le t \le 10^4$）代表数据组数，每组测试数据描述如下：  

第一行输入一个正偶数 $n$（$2 \leq n \leq 10^5$）代表数组元素数量。  

第二行输入 $n$ 个正整数 $a_1$，$a_2$，$\dots$，$a_n \left(1 \leq a_i \leq 10^9\right)$ 代表数组元素。  
  
除此之外，保证单个测试文件的 $n$ 之和不超过 $10^5$。





### 输出

对于每组测试数据，新起一行。输出一个整数，代表将该数组变成双生数组的最小操作次数。





### 样例

**样例输入：**

```cpp
3
4
1 1 3 1
4
6 6 6 6
6
1 1 4 4 1 4
```



**样例输出：**

```cpp
2
2
0
```





### 注意

==最后几题给你们来个大的！！！==

对于第一组测试数据，数组可以变成 $\{1$，$2$，$2$，$1\}$。需要操作 $2$ 次（方案不唯一，变成 $\{1$，$1$，$3$，$3\}$ 等也是可以的）。

对于第二组测试数据，数组可以变成 $\{5$，$6$，$5$，$6\}$。需要操作 $2$ 次。

对于第三组测试数据，给定的数组本身即为双生数组，无需操作。





### 题解

将数组排序，最优策略是将前半段元素统一变为 $t_1$，后半段元素统一变为 $t_2$。

令 $m=n/2$，先考虑前半段。对于对称元素对 $a_i$ 与 $a_{m-i+1}$，将其变为 $t_1$ 的成本为 $|t_1-a_i|+|t_1-a_{m-i+1}|$。
*   当 $t_1 \in [a_i, a_{m-i+1}]$ 时，成本最小，为 $a_{m-i+1}-a_i$。
*   当 $t_1$ 在区间外时，成本会更高。

为使总成本最小，$t_1$ 须取前半段元素的中位数。
*   若 $m$ 为奇数，$t_1$ 的最优值为中点值。
*   若 $m$ 为偶数，$t_1$ 的最优值可取在中间两元素间的任意整数。

同理求得 $t_2$ 后，因题目要求 $t_1 \neq t_2$，需进行调整。应使 $t_1$ 取其最优区间下界，$t_2$ 取其上界。若两者依然相等，则必须在将 $t_1$ 调整为 $t_1-1$ 或将 $t_2$ 调整为 $t_2+1$ 的方案中，选择成本更小的一种。



```cpp
void solve()
{
    int n;
    cin >> n;
    vector<int> nums(n + 1);
    for (int i = 1; i <= n; ++i) cin >> nums[i];
    sort(nums.begin(), nums.end());

    int m = n >> 1;
    int l1 = nums[(m + (m & 1)) >> 1], r1 = nums[m + ((m + (m & 1)) >> 1)];
    int l2 = l1 - 1, r2 = r1 + 1;
    int x1 = 0, x2 = 0, y1 = 0, y2 = 0;
    for (int i = 1; i <= m; ++i) x1 += abs(nums[i] - l1), x2 += abs(nums[i] - l2);
    for (int i = m + 1; i <= n; ++i) y1 += abs(nums[i] - r1), y2 += abs(nums[i] - r2);

    if (l1 == r1)
        cout << min(x1 + y2, x2 + y1) << endl;
    else
        cout << x1 + y1 << endl;
}
```