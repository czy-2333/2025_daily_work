## [字符串里串（Substring）](https://ac.nowcoder.com/acm/contest/95334/D)

**时间限制：** 1 s
**内存限制：** 1024 MB



牛可乐定义字符串 $s$ 的可爱度为最大的整数 $k$，满足存在一个长度为 $k$ 的连续 <u>子串</u> $a\large^{\text{∗}}$、和一个长度为 $k$ 的 <u>不连续子序列</u> $b\large^{\text{†}}$，满足 $a=b$。特别地，若不存在符合要求的 $a$，$b$，则可爱度为 $0$。



$\large^{\text{∗}}$子串为从原字符串中，连续的选择一段字符（可以全选、可以不选）得到的新字符串。  

$\large^{\text{†}}$仅在本题中，不连续子序列定义为至少由两段不相邻的 **非空** 子串构成。







### 输入
  
第一行输入一个整数 $n$（$3 \le n \le 2 \times 10^5$）代表字符串 $s$ 的长度。

第二行输入一个长度为 $n$、仅由小写字母组成的字符串 $s$ 代表给定的字符串。





### 输出

输出一个整数代表可爱度。





### 样例

**样例输入：**

```cpp
// 样例输入1
4
abcc

// 样例输入2
3
```



**样例输出：**

```cpp
// 样例输出1
3
aba

// 样例输出2
0
```





### 注意
  
==这题不是多测！！！==

对于第二组测试数据，不存在符合要求的子序列，故直接输出 $0$。





### 题解

记选定的子串为 $a=s[i \dots j]$。为了构造与 $a$ 相同的不连续子序列 $b$，最优策略是让 $b$ 的一部分尽可能长地与 $a$ 重合，另一部分则取单个字符。

这引申出两种构造方案：
*   $b$ 的第一部分是单个字符，即 $a$ 的首字符 $s[i]$，但在原字符串中取 $s[i]$ 的前一个出现位置；$b$ 的第二部分则对应 $a$ 的剩余部分 $s[i+1 \dots j]$。
*   $b$ 的第二部分是单个字符，即 $a$ 的尾字符 $s[j]$，但在原字符串中取 $s[j]$ 的后一个出现位置；$b$ 的第一部分则对应 $a$ 的剩余部分 $s[i \dots j-1]$。

这两种构造确保了 $b$ 的两部分在原字符串中不相邻，从而满足题意。为使长度最大化，我们只需对每个字符，分别计算以其第二次出现位置为起点的后缀长度，和以其倒数第二次出现位置为终点的前缀长度。

最终答案即为所有字符计算结果中的最大值。需要注意的是，由于不连续子序列的两段均不能为空，长度为 $1$ 的解不符合要求，此时答案为 $0$。



```cpp
void solve()
{
    int n;
    string str;
    cin >> n >> str;

    vector<vector<int>> mp(26);
    for (int i = 0; i < n; ++i) mp[str[i] - 'a'].push_back(i);

    int ans = 0;
    for (int i = 0; i < 26; ++i)
        if (mp[i].size() > 1)
            ans = max(ans, max(n - mp[i][1], mp[i][mp[i].size() - 2] + 1));

    cout << (ans == 1 ? 0 : ans) << endl;
}
```