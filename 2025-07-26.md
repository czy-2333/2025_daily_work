### [左转向下（Left and Down）](https://codeforces.com/contest/2125/problem/B)

**时间限制：** 2 s
**内存限制：** 512 MB

**输入：** 标准输入
**输出：** 标准输出



有一个机器人位于无限网格中的单元格 $(a$，$b)$。Misha 想把它移动到单元格 $(0$，$0)$。为此，她固定了一个整数 $k$。

Misha 可以执行以下操作：选择两个整数 $dx$ 和 $dy$（都在 $0$ 到 $k$ 的范围内，包括 $0$ 和 $k$），然后将机器人向左移动 $dx$ 个单元格（即 $x$ 坐标减小的方向），向下移动 $dy$ 个单元格（即 $y$ 坐标减小的方向）。换句话说，就是把机器人从位置 $(x$，$y)$ 移动到位置 $(x - dx$，$y - dy)$。

该操作的代价如下：

- 如果所选的 $(dx$，$dy)$ 这对数值是首次使用，操作代价为 $1$；
- 如果这对数值之前已经使用过，操作代价为 $0$。

注意：若 $dx \ne dy$，那么 $(dx$，$dy)$ 和 $(dy$，$dx)$ 被认为是不同的操作。

请帮助 Misha 用 **最小的总代价** 将机器人移动到 $(0$，$0)$。注意，这里 **不要求操作次数最少**。







### 输入

第一行包含一个整数 $t$（$1 \le t \le 10^4$），表示测试用例的数量。

接下来的每个测试用例包含一行，包含三个整数 $a$，$b$，$k$（$1 \le a$，$b$，$k \le 10^{18}$）。





### 输出

对于每个测试用例，输出一个整数，为将机器人移动到 $(0$，$0)$ 所需的最小总代价。





### 样例

**样例输入：**

```cpp
4
3 5 15
2 3 1
12 18 8
9 7 5
```



**样例输出：**

```cpp
1
2
1
2
```





### 注意

在第一个测试用例中，可以使用操作 $(3$，$5)$ 一次，机器人立即移动到 $(0$，$0)$，总代价为 $1$。

在第二个测试用例中，可以使用操作 $(1$，$1)$、$(0$，$1)$ 和 $(1$，$1)$。第一次操作后，机器人移动到 $(1$，$2)$；第二次后到达 $(1$，$1)$；第三次后到达 $(0$，$0)$。其中第一次和第二次操作的代价是 $1$，第三次使用了已使用的操作对，代价为 $0$，所以总代价为 $2$。

在第三个测试用例中，可以重复使用操作 $(4$，$6)$ 三次，总代价为 $1$。

在第四个测试用例中，可以使用操作 $(4$，$2)$ 和 $(5$，$5)$，总代价为 $2$。





### 题解

如果 $a$ 和 $b$ 除以最大公因数之后的结果都小于 $k$，那我们至少有一种操作在执行 $gcd(a$，$b)$ 次之后可以移动到 $(0$，$0)$，代价为 $1$；

如果上述情况不存在，则我们可以分别执行操作 $(1$，$0)\ a$ 次和 $(0$，$1)\ b$ 次后移动到 $(0$，$0)$，代价为 $2$。



```cpp
void solve()  
{  
    int a, b, k;  
    cin >> a >> b >> k;  
      
    if (a / gcd(a, b) <= k && b / gcd(a, b) <= k)  
       cout << 1 << endl;  
    else  
       cout << 2 << endl;  
}
```