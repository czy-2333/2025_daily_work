## [着迷于星辰的人（Bewitching Stargazer）](https://codeforces.com/problemset/problem/2053/C)

**时间限制：** 2 s
**内存限制：** 256 MB

**输入：** 标准输入
**输出：** 标准输出



我祈祷拥有一颗透明的心灵，和一双有足够多眼泪的眼睛……  	—— 逃跑计划，[《夜空中最亮的星》](https://www.youtube.com/watch?v=GPnymcrXgX0)

----
Iris 凝望着星空，一个美丽的问题在她脑海中浮现。她邀请你来解决这个问题，并期待一场流星雨的形成。

天空中共有 $n$ 颗星星，排成一列。Iris 有一个望远镜，她用它来观察这些星星。

最初，Iris 观察的是区间 $[1$，$n]$ 内的星星，她的幸运值为 $0$。对于她观察的每一个区间 $[l$，$r]$，Iris 都想找到中间位置的星星。因此，采用以下递归过程：

-   首先，她会计算 $m = \left\lfloor \frac{l+r}{2} \right\rfloor$。
-   如果区间的长度（即 $r - l + 1$）是偶数，Iris 会将其分成两个等长的区间 $[l$，$m]$ 和 $[m+1$，$r]$ 进行进一步观察。
-   否则，Iris 会将望远镜对准第 $m$ 颗星星，她的 **幸运值会增加** $m$；随后，如果 $l \neq r$，Iris 会继续观察两个新的区间 $[l$，$m-1]$ 和 $[m+1$，$r]$。

Iris 有点懒。她用一个整数 $k$ 来定义她的懒惰程度：在观察过程中，她不会继续观察任何长度 **严格小于** $k$ 的区间 $[l$，$r]$。在这种情况下，请预测她最终的幸运值。







### 输入

每个测试包含多个测试用例。输入的第一行包含一个整数 $t$（$1 \leq t \leq 10^5$），测试用例的数量。接下来是测试用例的描述。

每个测试用例的唯一一行包含两个整数 $n$ 和 $k$（$1 \leq k \leq n \leq 2\cdot 10^9$）。





### 输出

对于每个测试用例，输出一个整数，代表最终的幸运值。





### 样例

**样例输入：**

```cpp
6
7 2
11 3
55 13
5801 6
8919 64
8765432 1
```



**样例输出：**

```cpp
12
18
196
1975581
958900
38416403456028
```





### 注意

在第一个测试用例中，一开始 Iris 观察的是区间 $[1$，$7]$。

* 由于 $[1$，$7]$ 的长度为奇数，因此她瞄准第 $4$ 颗星星，从而将她的幸运值增加 $4$。然后该区间被分割为两个新区间：$[1$，$3]$ 和 $[5$，$7]$。
* 区间 $[1$，$3]$ 的长度仍为奇数，因此 Iris 瞄准第 $2$ 颗星星，幸运值增加 $2$。
* 接着该区间被分割为两个新区间：$[1$，$1]$ 和 $[3$，$3]$，这两个区间的长度都小于 $2$，因此不会再进行进一步观察。
* 对于区间 $[5$，$7]$，处理过程类似，最终幸运值增加 $6$。

因此，最终的幸运值为 $4 + 2 + 6 = 12$。

在最后一个测试用例中，Iris 最终观察了所有星星，最终的幸运值为 $1 + 2 + \cdots + 8,765,432 = 38,416,403,456,028$。





### 题解

该题解的核心技巧是利用对称性来简化计算。

我们无需追踪每个区间的具体位置 $[l$，$r]$，只需关心在每一轮操作中，区间的**数量**和**长度**。

关键在于，分裂出的区间总是两两对称的。一对对称区间的中心点相加，其和恒等于 $n+1$。

因此，当需要计算幸运值时（即区间长度为奇数），我们不必单独计算每个中心点。我们直接将区间对的数量（即总区间数除以$2$）乘以 $(n+1)$，就能得到这一轮增加的总幸运值。

整个过程就变成了：模拟每一轮中区间的数量和长度变化，并在长度为奇数时，利用上述技巧批量计算幸运值，直到所有区间长度都小于 $k$ 为止。



```cpp
void solve()  
{  
    int n, k;  
    cin >> n >> k;  
    int mul = n + 1, sum = 0, cur = 1;  
    while (n >= k)  
    {  
       if (n & 1) sum += cur;  
       n >>= 1;  
       cur <<= 1;  
    }  
    cout << mul * sum / 2 << endl;  
}
```