## [旅行购物（Trip Shopping）](https://codeforces.com/contest/2127/problem/C)

**时间限制：** 2 s
**内存限制：** 256 MB



Ali 和 Bahamin 决定在伊朗美丽的南部海岸度过他们的暑假。他们还同意在旅途中进行一些购物，但他们没有设定固定的预算，而是决定通过玩一个游戏来决定花多少钱。

游戏在两个数组 $a$ 和 $b$ 上进行，每个数组包含 $n$ 个整数。

游戏将进行 $k$ 轮。在一轮中：

-   首先，Ali 选择两个索引 $i$ 和 $j$（$1 \leq i < j \leq n$）；
-   然后，Bahamin **任意重排** 这四个整数 $a_i$、$a_j$、$b_i$ 和 $b_j$。请注意，Bahamin 可以在两个数组之间交换数字。他也 **可以保持两个数组不变**。

在所有 $k$ 轮结束后，游戏的值定义为 $v=\sum\limits_{i=1}^{n} |a_i-b_i|$。Ali 和 Bahamin 在旅途中将花费恰好 $v$ 个金币。

然而，他们的目标截然不同：

-   Ali 希望花费得尽可能少，即最小化 $v$；
-   Bahamin 希望花费得尽可能多，即最大化 $v$。

你必须找出在 Ali 和 Bahamin 都采取最优策略的情况下，他们最终将花费的金币数量。







### 输入

每个测试包含多个测试用例。第一行包含测试用例的数量 $t$（$1 \le t \le 10^4$）。接下来是测试用例的描述。

每个测试用例的第一行包含两个整数 $n$ 和 $k$（$2 \leq n \leq 2 \cdot 10^5$，$1 \leq k \leq n$），数组 $a$ 和 $b$ 的长度，以及游戏的回合数。

第二行包含 $n$ 个整数 $a_1$，$a_2$，$\ldots$，$a_n$（$1 \leq a_i \leq 10^9$），数组 $a$ 的元素。

第三行包含 $n$ 个整数 $b_1$，$b_2$，$\ldots$，$b_n$（$1 \leq b_i \leq 10^9$），数组 $b$ 的元素。

保证所有测试用例的 $n$ 的总和不超过 $2 \cdot 10^5$。





### 输出

对于每个测试用例，输出一个整数，在双方都采取最优策略的情况下，他们最终将花费的金币数量。





### 样例

**样例输入：**

```cpp
5
2 1
1 7
3 5
3 2
1 5 3
6 2 4
5 4
1 16 10 10 16
3 2 2 15 15
4 1
23 1 18 4
19 2 10 3
10 10
4 3 2 100 4 1 2 4 5 5
1 200 4 5 6 1 10 2 3 4
```



**样例输出：**

```cpp
8
9
30
16
312
```





### 注意

在第一个测试用例中，Ali 只能选择 $(i$，$j) = (1$，$2)$，而 Bahamin 可以重排所有四个数字。因此，他可以将数组设置为 $a = [5, 1]$ 和 $b =[3, 7]$。此时游戏的值为 $v=|5 - 3| + |1 - 7| = 8$。可以证明，这是 Bahamin 能达到的最大可能值（其他的排列方式，如 $a =[5$，$7]$，$\space b =[1$，$3]$ 也是可能的，但它们的值不会更大）。

在第二个测试用例中，无论 Ali 选择哪个索引，Bahamin 的最佳策略都是保持两个数组不变。此时游戏的值为 $v=|1 - 6| + |5 - 2| + |3 - 4| = 9$。





### 题解

由于 Ali 可以在 $k$ 轮中重复选择同一对索引，而 Bahamin 对已经操作过的索引对无法获得更多收益，因此轮数 $k$ 不影响最终结果，问题可以简化为只进行一轮决策。这使得问题转化为 Ali 如何选择一对最优索引 $(i$，$j)$。

首先，对任意 $i$，我们可以令 $a_i$ 为原数对中的较小值，$b_i$ 为较大值，这不改变 $\sum|a_i-b_i|$ 的总和。然后，我们将所有数对 $(a_i$，$b_i)$ 按照 $a_i$ 的值升序排列。

假设 Ali 选择了已排序的索引 $i$ 和 $j$（$i < j$），Bahamin 操作后能获得的最大增益为四个值 $a_i$，$a_j$，$b_i$，$b_j$ 重新配对后的总和与原总和的差值。

* 经过推导，该增益可表示为：$|b_j - a_i| + |b_i - a_j| - (b_j - a_j) - (b_i - a_i)$。
* 由于我们已排序使得 $a_i \le a_j \le b_j$，因此 $b_j-a_i \ge 0$，公式可化简为：$b_j - a_i + |b_i - a_j| - b_j + a_j - b_i + a_i$。
* 进一步整理得到：$|b_i - a_j| + a_j - b_i$。

我们分析这个增益表达式：
*  如果 $b_i \ge a_j$，增益为 $(b_i - a_j) + a_j - b_i = 0$。
*  如果 $b_i < a_j$，增益为 $(a_j - b_i) + a_j - b_i = 2(a_j - b_i)$。

Ali 的目标是最小化这个增益。因此，他会优先寻找是否存在一对索引 $(i$，$j)$ 满足 $b_i \ge a_j$ 来使增益为 $0$。若不存在这样的索引对，则意味着对于所有 $i<j$ 都有 $b_i < a_j$，Ali 只好退而求其次，选择能使 $2(a_j - b_i)$ 最小的一对索引。在已经按 $a_i$ 排序的数组中，这个最小增益可以通过一次遍历高效求得。



```cpp
void solve()
{
    int n, k;
    cin >> n >> k;
    vector<pair<int, int>> nums(n);
    int add = 9e18, sum = 0;
    for (int i = 0; i < n; ++i) cin >> nums[i].x;
    for (int i = 0; i < n; ++i)
    {
        cin >> nums[i].y;
        nums[i] = {min(nums[i].x, nums[i].y), max(nums[i].x, nums[i].y)};
        sum += nums[i].y - nums[i].x;
    }
    sort(nums.begin(), nums.end());
    for (int i = 1, t = nums[0].y; i < n; ++i)
    {
        add = t > nums[i].x ? 0 : min(add, 2 * (nums[i].x - t));
        t = max(t, nums[i].y);
    }  
    cout << sum + add << endl;
}
```