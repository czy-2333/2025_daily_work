### [最小化前缀最小值之和（Minimise Sum）](https://codeforces.com/contest/2124/problem/B)

**时间限制：** 1.5 s
**内存限制：** 256 MB

**输入：** 标准输入
**输出：** 标准输出



给定一个长度为 $n$ 的数组 $a$，其中每个元素满足 $0 \le a_i \le n$。你 **最多** 可以执行以下操作 **一次**：

选择两个下标 $i < j$，然后执行操作：令 $a_i = a_i + a_j$，接着令 $a_j = 0$。

你需要输出你能获得的 $\min(a_1) + \min(a_1$，$a_2) + \min(a_1$，$a_2$，$a_3) + \ldots + \min(a_1$，$\ldots$，$a_n)$ 的 **最小值**。







### 输入

每个测试文件中包含多个测试用例。

第一行包含一个整数 $t$（$1 \le t \le 10^4$），表示测试用例的数量。

接下来的第二行包含 $n$ 个用空格分隔的整数 $a_1$，$a_2$，$\ldots$，$a_n$（$0 \le a_i \le n$），表示数组 $a$。

保证所有测试用例中 $n$ 的总和不超过 $2 \cdot 10^5$。





### 输出

**输出**

对于每个测试用例，输出一个整数，表示 $\min(a_1) + \min(a_1$，$a_2) + \ldots + \min(a_1$，$a_2$，$\ldots$，$a_n)$ 的最小可能值。





### 样例

**样例输入：**

```cpp
3
2
1 2
3
1 2 3
4
3 0 2 3
```



**样例输出：**

```cpp
2
2
3
```





### 注意

在第二个测试用例中，最优操作是选择 $i=2$，$j=3$ 进行操作。

在第三个测试用例中，最优解是不进行任何操作，答案是 3。





### 题解

答案是 $\min(a_1$，$a_2)+a_1$。

* 如果 $a_1 > a_2$，我们可以执行操作 $i=1$ 和 $j=2$，这样在索引 $2$ 之后的前缀最小值将始终为 $0$，从而得到 $a_1 + a_2$ 作为我们的答案。

* 如果 $a_1 < a_2$，我们可以执行操作 $i=2$ 和 $j=3$。由于 $a_1 < a_2$，因此 $\min(a_1$，$a_2)=a_1$。在索引 $3$ 及之后的前缀最小值将为 $0$。我们需要注意边界情况 $n=2$，因为没有可以使用的索引 $3$。然而，如果 $n=2$，我们可以简单地不执行该操作。

我们可以很容易地证明上述情况对这个问题是最优的。



```cpp
void solve()
{
	int n;
	cin >> n;
	vector<int> nums(n);
	for (int i = 0; i < n; ++i) cin >> nums[i];
	cout << nums[0] + min(nums[0], nums[1]) << endl;
}
```