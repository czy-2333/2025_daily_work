## [铁刀磨成针（Grind Iron Knife to Needle）](https://ac.nowcoder.com/acm/contest/95338/J)

**时间限制：** 1 s
**内存限制：** 256 MB

**输入：** 标准输入
**输出：** 标准输出



小鸡最近沉迷于 Hearthstone 中的刀贼卡组，该卡组秉承开局一把刀、输出全靠砍的思想，力求对敌方造成尽可能多的伤害。  

一把刀初始攻击力为 $x$，接下来有 $n$ 个回合，每回合按顺序包括以下两个阶段：  

* 磨刀阶段：可以选择花费一单位磨刀石提升刀的攻击力一点（**每回合最多一次**）；  
* 攻击阶段：可以选择攻击，会对敌方造成等同于刀攻击力的伤害、并使刀的攻击力减一（**每回合最多一次**）。刀的攻击力归零时会损坏、此后再也不能攻击。 

假设初始磨刀石的个数是 $y$，给定 $n$，$x$，$y$，求最大造成的伤害。







### 输入

每个测试文件中包含多组测试数据。第一行输入一个整数 $t$（$1 \le t \le 10^4$）代表数据组数，每组测试数据描述如下：

第一行输入三个正整数 $n$，$x$，$y$（$1 \le x$，$y \le 10^{3}$；$1 \le n \le 10^{9}$）代表回合数、初始攻击力、初始磨刀石数量。 

注意本题对多个测试文件的 $n$，$x$，$y$ 之和没有额外的限制。





### 输出

对于每一组测试数据，输出一行一个整数，代表最大造成的伤害。





### 样例

**样例输入：**

```cpp
3
2 1 1
5 1 3
5 1 5
```



**样例输出：**

```cpp
3
9
12
```





### 注意

在本题中，若总操作次数不超过 $10^7$，在评测环境下一般不会超时。





### 题解

由于尽早磨刀总能让后续攻击的伤害更高，最优策略必然是从首回合开始连续磨刀，直至磨刀石全部用完或回合数耗尽。因此，磨刀的方式是固定的。

我们只需决定何时开始攻击。可以证明，最优解中的所有攻击必定发生在连续的回合内。因为若攻击不连续，将较早的攻击推迟，总能因受益于更多的磨刀次数而使伤害增加。

因此，我们只需枚举首次攻击的回合。当磨刀石数 $y$ 小于总回合数 $n$ 时，从第 $y+1$ 回合开始攻击，不会比从第 $y$ 回合开始更优。故只需枚举到第 $y$ 回合作为攻击起点即可。

确定攻击起点后，伤害分为两部分：一是磨刀与攻击并存的阶段，此间武器攻击力不变；二是仅进行攻击的阶段，武器攻击力构成一个等差数列。将两部分伤害分别计算后求和即可。



```cpp
void solve()
{
	int n, x, y;
	cin >> n >> x >> y;
	y = min(y, n);

	int ans = 0;
	for (int i = 1; i <= y; ++i)
	{
		int r = x + i;
		int l = max(0, r - (n - y));
		ans = max(ans, r * (y - i) + (r + l) * (r - l + 1) / 2);
	}
	cout << ans << endl;
}
```