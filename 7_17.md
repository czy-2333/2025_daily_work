### [前财务官的我，帮哥布林诈骗（Having Been a Treasurer in the Past, I Help Goblins Deceive）](https://codeforces.com/problemset/problem/2072/B)

**时间限制：** 2 s
**内存限制：** 256 MB

**输入：** 标准输入
**输出：** 标准输出



在上一个任务后，Akito 离开了起始洞穴。不久之后，他偶然来到了一个哥布林村庄。

由于 Akito 没有住处，他想了解一下当地的住房价格。众所周知，哥布林使用由字符 `'-'` 和 `'_'` 构成的字符串来表示数字，而一个字符串 $s$ 所代表的数值是：字符串 $s$ 中所有等于字符串 `"-_-"` 的 **不同子序列**$\large^{\text{∗}}$ 的数量（这非常像哥布林的脸）。

例如，字符串 $s = $ `"-_--_-"` 表示的数值为 $6$，因为它包含 $6$ 个子序列 `"-_-"`：

1. $s_1 + s_2 + s_3$
2. $s_1 + s_2 + s_4$
3. $s_1 + s_2 + s_6$
4. $s_1 + s_5 + s_6$
5. $s_3 + s_5 + s_6$
6. $s_4 + s_5 + s_6$

一开始，哥布林们随机写了一个字符串数 $s$ 来回答 Akito 的问题，但随后他们意识到，应该想办法从旅行者手中拿到尽可能多的金币。于是，他们请求你重新排列字符串 $s$ 中的字符，使得该字符串所表示的数值最大。



$\large^{\text{∗}}$ 一个字符串 $a$ 的子序列是指可以通过删除 $a$ 中若干（可能为 $0$ 个）字符得到的字符串 $b$。如果删除的是不同位置的字符，则子序列被视为不同的。







### 输入

第一行是一个整数 $t$（$1 \le t \le 10^4$），表示测试用例的数量。

接下来的每组测试用例包含两行：

* 第一行包含一个整数 $n$（$1 \le n \le 2 \cdot 10^5$），字符串 $s$ 的长度；
* 第二行包含一个仅由 `'-'` 和 `'_'` 构成的字符串 $s$，长度为 $n$，即哥布林写下的字符串。

保证所有测试用例中 $n$ 的总和不超过 $2 \cdot 10^5$。





### 输出

对于每组测试用例，输出一个整数——将字符串 $s$ 中的字符重新排列后，可以得到的子序列 `"-_-"` 的最大数量。





### 样例

**样例输入：**

```
8
3
--_
5
__-__
9
--__-_---
4
_--_
10
_-_-_-_-_-
7
_------
1
-
2
_-
```



**样例输出：**

```
1
0
27
2
30
9
0
0
```





### 注意

在第一个测试用例中，将字符重新排列为 `"-_-"` 后，可以构造出一个子序列 `"-_-"`，所以答案为 $1$。

在第二个测试用例中，只有一个 `'-'`，而要形成 `"-_-"` 至少需要两个 `'-'` 和一个 `'_'`，因此无论怎么重排，答案都是 $0$。

在第七和第八个测试用例中，字符串长度 $n < 3$，无法形成长度为 $3$ 的子序列，答案也为 $0$。





### xxxxxxxxxx9 1void solve()2{3    int x, y;4    cin >> x >> y;5    if (x == 1 || y == 1)6        cout << -1 << endl;7    else8        cout << 1 << endl;9}cpp

当 $n \le 2$，或字符串中 `'-'` 的数量不足 2，或没有 `'_'`，无法构成符合条件的子序列，答案为 $0$。

否则，设 `'-'` 的数量为 $c$，`'_'` 的数量为 $n - c$。
 我们希望从前缀和后缀的 `'-'` 中各选一个，夹住一个 `'_'`，形成合法子序列。为使数量最大，需将 $c$ 拆为尽量平衡的两部分，即：

- $\ell_p = \left\lfloor \frac{c}{2} \right\rfloor$
- $\ell_s = \left\lceil \frac{c}{2} \right\rceil$

每个 `'_'` 可与任意一对前缀、后缀 `'-'` 组合，数量为：
$$
\ell_p \cdot \ell_s \cdot (n - c)
$$
即最终答案为：
$$
\left\lfloor \frac{c}{2} \right\rfloor \cdot \left\lceil \frac{c}{2} \right\rceil \cdot (n - c)
$$




```cpp
void solve()
{
    int n;
    string str;
    cin >> n >> str;
    int dash = count(str.begin(), str.end(), '-');
    int under = n - dash;
    int ans = (dash / 2) * (dash - dash / 2) * under;
    cout << ans << endl;
}
```
