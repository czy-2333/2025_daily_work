### [异或三角形（XOR and Triangle）](https://codeforces.com/problemset/problem/2074/C)

**时间限制：** 2 s
**内存限制：** 256 MB

**输入：** 标准输入
**输出：** 标准输出



这次，粉色士兵给了你一个整数 $x$ ($x \ge 2$)。

请确定是否存在一个 **正** 整数 $y$ 满足以下条件。

-   $y$ **严格** 小于 $x$。
-   存在一个 **非退化三角形**$\large{^{\text{∗}}}$，其边长为 $x$、$y$、$x \oplus y$。这里，$\oplus$ 表示 [按位异或运算](https://en.wikipedia.org/wiki/Bitwise_operation#XOR)。

此外，如果存在这样的整数 $y$，请输出任意一个。



$\large{^{\text{∗}}}$ 边长为 $a$、$b$、$c$ 的三角形是非退化的，当且仅当 $a+b > c$ 、$a+c > b$ 、$b+c > a$。







### 输入

每个测试包含多个测试用例。第一行包含测试用例的数量 $t$ ($1 \le t \le 2000$)。测试用例的描述如下。

每个测试用例的唯一一行包含一个整数 $x$ ($2 \le x \le 10^9$)。





### 输出

对于每个测试用例，在单独的一行上打印一个整数。你必须输出的整数如下：

-   如果存在一个满足条件的整数 $y$，输出 $y$ 的值 ($1 \le y < x$)；
-   否则，输出 $-1$。

如果存在多个满足条件的整数，你可以输出任意一个。





### 样例

**样例输入：**

```
7
5
2
6
3
69
4
420
```



**样例输出：**

```
3
-1
5
-1
66
-1
320
```





### 注意

在第一个测试用例中，存在一个非退化三角形，其边长为 $3$、$5$ 和 $3 \oplus 5 = 6$。因此，$y=3$ 是一个有效的答案。

在第二个测试用例中，$1$ 是唯一可能的 $y$ 候选值，但它无法形成一个非退化三角形。因此，答案是 $-1$。





### 题解

让我们用位运算的方式来理解三角不等式。由此我们可以得到如下表达式（其中一条已在题目限制中隐含，因此省略）：

- $x + y > x \oplus y {\large\text{ }\Longrightarrow\text{ }} (x \oplus y) + 2(x\text{ }\&\text{ }y) > x \oplus y {\large\text{ }\Longrightarrow\text{ }} x\text{ }\&\text{ }y > 0$；
- $y + (x \oplus y) > x {\large\text{ }\Longrightarrow\text{ }} y + (x + y) - 2(x\text{ }\&\text{ }y) > x {\large\text{ }\Longrightarrow\text{ }} y > x\text{ }\&\text{ }y$。

换句话说，$y$ 需要满足以下两个条件：

- $y$ 中**至少有一个**在 $x$ 中为 1 的比特也为 1；
- $y$ 中**至少有一个**在 $x$ 中为 0 的比特也为 1。

满足这两个条件的最小 $y$ 是具有恰好两个比特为 1 的数：一个与 $x$ 的某个比特位置相同（为 1），另一个在 $x$ 中原本为 0 的位置上为 1。

因此，如果存在这样的 $y$，那么可以通过**枚举所有恰好两个比特为 1 的整数**来在 $\mathcal{O}(\log^2 x)$ 的时间内找到最小的满足条件的值。如果其中有任何一个小于 $x$，那么它就满足所有条件。

该问题已经被解决在每个测试用例 $\mathcal{O}(\log^2 x)$ 的复杂度内。虽然存在 $\mathcal{O}(\log x)$ 的解法，但并不是必要的。



```cpp
void solve()
{
	int x, y, z;
	cin >> x;

	int ans = -1;
	for (int i = 0; i < 30; ++i)
	{
		for (int j = 0; j < 30; ++j)
		{
			y = 1 << i | 1 << j;
			z = x ^ y;
			if (x > y && x + y > z && x + z > y && y + z > x)
				i = j = 32, ans = y;
		}
	}
	cout << ans << el;
}
```





