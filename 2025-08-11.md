## [烤肉串（Shashlik Cooking）](https://codeforces.com/contest/1040/problem/B)

**时间限制：** 1 s
**内存限制：** 512 MB



长话短说，烤肉串是 Miroslav 最喜欢的食物。烤肉串是在几根烤肉签上同时烹制的。每根烤肉签都有两种状态：**初始状态** 和 **翻转状态**。

这一次，Miroslav 并排摆放了 $n$ 根烤肉签，并从左到右用 $1$ 到 $n$ 的连续整数对它们进行了编号。为了让肉烤得更好，他把它们放得非常靠近，所以当他翻转第 $i$ 号烤肉签时，会连带着把它两侧最近的各 $k$ 根烤肉签也一起翻转。也就是说，编号为 $i - k$，$i - k + 1$，$...$，$i - 1$，$i + 1$，$...$，$i + k - 1$，$i + k$ 的烤肉签也会被翻转（如果这些编号存在的话）。

举个例子，假设 $n = 6$ 且 $k = 1$。当 Miroslav 翻转第 $3$ 号烤肉签时，编号为 $2$，$3$，$4$ 的烤肉签都会变成翻转状态。如果在这之后他再去翻转第 $1$ 号烤肉签，那么最终编号为 $1$，$3$，$4$ 的烤肉签会处于翻转状态，而第 $2$ 号烤肉签会 **回到初始状态（因为它被再次翻转了）**。

正如我们之前所说，烹饪的艺术需要完美的时机把握，所以 Miroslav 希望用 **最少的操作次数** 将所有 $n$ 根烤肉签全部翻转。例如，在上面 $n = 6, k = 1$ 的例子中，两次操作就足够了：他可以翻转第 $2$ 号和第 $5$ 号烤肉签。

请帮助 Miroslav 翻转所有的 $n$ 根烤肉签。







### 输入

输入的第一行包含两个整数 $n$ 和 $k$（$1 \leq n \leq 1000$，$0 \leq k \leq 1000$），分别是烤肉签的数量和每次操作时单侧受影响的烤肉签数量。





### 输出

第一行应该输出一个整数 $l$ ，Miroslav 将所有 $n$ 根烤肉签全部翻转所需的最少操作次数。

接下来一行，输出 $l$ 个从 $1$ 到 $n$ 的整数，表示对应步骤中需要翻转的烤肉签的编号。





### 样例

**样例输入：**

```cpp
// 样例输入1
7 2

// 样例输入2
5 1
```



**样例输出：**

```cpp
// 样例输出1
2  
1 6

// 样例输出2
2  
1 4
```





### 注意

==这题不是多测！！！==
  
在第一个示例中，第一次操作翻转了 $1$，$2$，$3$ 号烤肉签，第二次操作翻转了 $4$，$5$，$6$，$7$ 号烤肉签。

在第二个示例中，翻转 $2$ 号和 $5$ 号烤肉签也是一个正确的答案，但是翻转 $2$ 号和 $4$ 号，或者 $1$ 号和 $5$ 号则是不正确的方案，因为经过这些操作后，第 $3$ 号烤肉签仍然处于初始状态。





### 题解

根据贪心思想，为使单次翻转覆盖最多根烤串，应选择能一次性翻转 $2k+1$ 根的位置。为避免重复翻转，我们可以从第 $k+1$ 根烤串开始，然后以 $2k+1$ 为间隔进行后续翻转。此策略在执行 $\lfloor n/(2k+1) \rfloor$ 次后，会在末尾留下 $m = n \pmod{2k+1}$ 根未被翻转的烤串。

*   若 $m > k$，只需在剩余的这 $m$ 根烤串中，翻转其第 $k+1$ 根，即可将所有剩余部分翻转。
*   若 $m \le k$，则在剩余的 $m$ 根中无法找到一个点能一次性翻转全部。此时需调整初始策略，将首次翻转的位置从 $k+1$ 前移至 $1$。该调整使末端未翻转的区域扩大为 $m' = m+k$，并满足 $k < m' < 2k+1$，问题随之转化为前一种情况，同样翻转该区域中的第 $k+1$ 根即可。



```cpp
void solve()
{
    int n, m, k, l;
    cin >> n >> k;
    m = n % (2 * k + 1);
    l = m && m <= k ? 1 : k + 1;
    cout << (n - l) / (2 * k + 1) + 1 << endl;
    for (int i = l; i <= n; i += 2 * k + 1) cout << i << " ";
    cout << endl;
}
```