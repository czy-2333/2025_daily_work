## [树之收缩（Arboris Contractio）](https://codeforces.com/contest/2131/problem/D)

**时间限制：** 2 s
**内存限制：** 256 MB



Kagari 正准备将一棵树存档，她知道存档的成本将取决于其 <u>直径</u>$\large^{\text{∗}}$。为了降低开销，她的目标是首先 **将直径尽可能地缩小**。她可以对树执行以下操作：

1.  选择两个顶点 $s$ 和 $t$。设从 $s$ 到 $t$ 的 <u>简单路径</u>$\large^{\text{†}}$ 上的顶点序列为 $v_0$，$v_1$，$\dots$，$v_k$，其中 $v_0 = s$ 且 $v_k = t$。
2.  **移除路径上的所有边**。换句话说，移除边 $(v_0$，$v_1)$，$(v_1$，$v_2)$，$\dots$，$(v_{k-1}$，$v_k)$。
3.  将顶点 $v_1$，$v_2$，$\dots$，$v_k$ 直接连接到 $v_0$。换句话说，添加边 $(v_0$，$v_1)$，$(v_0$，$v_2)$，$\dots$，$(v_0$，$v_k)$。

可以证明，操作后该图仍然是一棵树。

请帮助她确定，为了达到可能的最小直径，所需的最少操作次数是多少。



$\large^{\text{∗}}$树的直径是任意一对顶点之间可能的最长距离。距离本身由连接它们的唯一简单路径上的边数来衡量。

$\large^{\text{†}}$简单路径是树中两个顶点之间的路径，它不会多次访问任何顶点。可以证明，任意两个顶点之间的简单路径总是唯一的。







### 输入

每个测试包含多个测试用例。第一行包含测试用例的数量 $t$（$1 \le t \le 10^4$）。接下来是各个测试用例的描述。

每个测试用例的第一行包含一个整数 $n$（$2 \le n \le 2 \cdot 10^5$），树中顶点的数量。

每个测试用例的接下来 $n-1$ 行描述了这棵树。每行包含两个整数 $u$ 和 $v$（$1 \le u$，$v \le n$，$u \neq v$），表示顶点 $u$ 和 $v$ 之间存在一条边。保证这些边构成一棵树。

保证所有测试用例的 $n$ 的总和不超过 $2 \cdot 10^5$。





### 输出

对于每个测试用例，输出一个整数，达到最小直径所需的最少操作次数。





### 样例

**样例输入：**

```cpp
4
4
1 2
1 3
2 4
2
2 1
4
1 2
2 3
2 4
11
1 2
1 3
2 4
3 5
3 8
5 6
5 7
7 9
7 10
5 11
```



**样例输出：**

```cpp
1
0
0
4
```





### 注意

==这题和树没有关系！！！==

在第一个测试用例中，原始树的直径为 $3$。Kagari 可以对 $s = 3$ 和 $t = 4$ 执行一次操作。如下图所示，该操作包括以下步骤：

1.  移除边 $(3$，$1)$、$(1$，$2)$ 和 $(2$，$4)$。
2.  添加边 $(3$，$1)$、$(3$，$2)$ 和 $(3$，$4)$。

![](assets/2025-08-14-01.png)

操作后，直径减小到 $2$。可以证明 $2$ 是最小的可能直径。

在第二个测试用例中，树的直径为 $1$。可以证明 $1$ 已经是最小值，所以 Kagari 可以不执行任何操作。





### 题解

明天发！！！



```cpp
void solve()  
{  
    /*code*/
}
```