## [惊艳指数（WOW Factor）](https://codeforces.com/contest/1178/problem/B)

**时间限制：** 1 s
**内存限制：** 512 MB



一个字符串的 **惊艳指数** 是其等于单词 $wow$ 的 <u>子序列</u>$^{\large\text{∗}}$ 的数量。Bob 想写一个具有很大惊艳指数的字符串。然而，他键盘上的 $w$ 键坏了，所以他用两个 $v$ 来代替。

但他没有意识到，他可能创造出了比他想象中更多的 $w$。例如，考虑字符串 $ww$。Bob 会将其输入为 $vvvv$，但这个字符串实际上包含了三个 $w$ 的出现：

* ${\color{orange}{vv}}vv$
* $v{\color{orange}{vv}}v$
* $vv{\color{orange}{vv}}$

例如，单词 $vvvovvv$ 的惊艳指数等于 4，因为有四个 $wow$：

* ${\color{orange}{vv}}v{\color{orange}{o}}v{\color{orange}{vv}}$
* ${\color{orange}{vv}}v{\color{orange}{ovv}}v$
* $v{\color{orange}{vvo}}v{\color{orange}{vv}}$
* $v{\color{orange}{vvovv}}v$

请注意，子序列 ${\color{orange}{v}}v{\color{orange}{vovv}}v$ 不计入惊艳指数，因为组成 $w$ 的两个 $v$ **必须是连续的**。

对于一个给定的字符串 $s$，计算并输出其惊艳指数。请注意，我们 **不保证** 字符串 $s$ 是由某个其他字符串通过将 $w$ 替换为 $vv$ 得到的。例如，$s$ 可以等于 $vov$。



$\large^{\text{∗}}$一个字符串 $a$ 的子序列是指可以通过删除 $a$ 中若干（可能为 $0$ 个）字符得到的字符串 $b$。如果删除的是不同位置的字符，则子序列被视为不同的。







### 输入

输入包含一个非空字符串 $s$，它仅由字符 $v$ 和 $o$ 组成。字符串 $s$ 的长度最多为 $10^6$。





### 输出

输出一个整数，即字符串 $s$ 的惊艳指数。





### 样例

**样例输入：**

```cpp
// 样例输入1
vvvovvv

// 样例输入2
vvovooovovvovoovoovvvvovovvvov
```



**样例输出：**

```cpp
// 样例输出1
4

// 样例输出2
100
```





### 注意

==这题不是多测！！！==
  
第一个例子已在题干中进行了解释。





### 题解

简单动态规划，用两个变量存储连续两个 $vv$ 的数量和已经记录的 $vvo$ 的数量，从左到右遍历字符串。

当遇到一对连续的 $v$ 时（这代表一个 $w$），这个 $w$ 可以和所有在它之前的 $vvo$（即 $wo$）子序列构成 $vvovv$（即 $wow$）。因此，我们将已记录的 $vvo$ 子序列的数量累加到最终的惊艳指数上。之后，我们再更新 $vv$ 的计数。

当遇到一个 $o$ 时，这个 $o$ 可以和所有在它之前的 $vv$（即 $w$）组合成 $vvo$（即 $wo$）。因此，我们将已记录的 $vv$ 的数量累加到 $vvo$ 的计数中。



```cpp
void solve()
{
    string str;
    cin >> str;
    int ans = 0, cnt = 0, mid = 0;
    for (int i = 1; i < str.length(); ++i)
    {
        if (str[i] == 'v' && str[i - 1] == 'v')
            cnt++, ans += mid;
        else if (str[i] == 'o')
            mid += cnt;
    }
    cout << ans << endl;
}
```