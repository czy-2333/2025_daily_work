### [遥控（Distant Control）](https://ac.nowcoder.com/acm/contest/108300/D)

**时间限制：** 1 s
**内存限制：** 512 MB

**输入：** 标准输入
**输出：** 标准输出



你有 $n$ 个机器人朋友，它们按顺序排成一排，从左到右编号为 $1$，$2$，$\dots$，$n$。最初，一些机器人是关闭的，另一些是开启的。

你的手机可以远程控制机器人的电源状态，但不幸的是，它并不总是非常精确。具体来说，存在一个常数 $1 \le a \le n - 1$，你只能通过手机执行以下两种操作：

* 选择 $a$ 个连续编号且 **全部处于开机** 状态的机器人，将它们 **全部设置为关机**；
* 选择 $a+1$ 个连续编号且 **全部处于关机** 的机器人，将它们 **全部设置为开机**。

你想要确定，经过若干次（可能为 $0$ 次）操作后，最多能有多少个机器人是开启状态。







### 输入

每个测试用例包含多个数据。第一行输入一个整数 $t$（$1 \le t \le 4 \cdot 10^4$），表示测试用例的数量。接下来的每组测试数据描述如下：

每个测试用例的第一行包含两个整数 $n$ 和 $a$（$2 \le n \le 2 \cdot 10^5$，$1 \le a \le n - 1$）。

每个测试用例的第二行包含一个长度为 $n$ 的仅由 $0$ 和 $1$ 组成的字符串 $S$，描述机器人的初始电源状态。具体来说，当且仅当 $s_i = 1$ 时，第 $i$ 个机器人是开启的。

保证所有测试用例中 $n$ 的总和不超过 $4 \cdot 10^5$。





### 输出

对于每个测试用例，输出一行一个整数：最多能有多少个机器人是开启状态。





### 样例

**样例输入：**

```cpp
4
3 1
001
4 3
0101
5 2
10110
10 4
1011010001
```



**样例输出：**

```cpp
3
2
5
5
```





### 注意

1. 代价为 1：
    若存在一个 "基本步" 能独立完成任务，则代价为 1。这个基本步是将总位移 $(a$，$b)$ 约分到最简形式：$$ (dx\text{，}dy) = \left( \frac{a}{\text{gcd}(a\text{，}b)}\text{，}\frac{b}{\text{gcd}(a\text{，}b)} \right)$$如果 $dx \le k$ 并且 $dy \le k$，则此方案可行，总代价为 $1$。

2. 代价为 2：
    如果上述条件不成立，则没有任何一种单一操作能完成任务。
	此时，我们退而求其次，采用两种最基础的操作：$(1$，$0)$ 和 $(0$，$1)$。这总能将机器人移动到原点，总代价为 $2$。






### 题解

如果初始时存在连续的至少 $a + 1$ 个关机机器人，可以把他们开机。

而一旦存在连续的 $a$ 个开机机器人，就可以不断拓展开机的连续段，使得所有机器人均开机。

于是若初始能进行任何合法操作，答案为 $n$；否则答案为初始时 $1$ 的个数。



```cpp
void solve()
{
	int n, k;
	string str;
	cin >> n >> k >> str;

	string a(k, '1'), b(k + 1, '0');
	if (str.find(a) != -1 || str.find(b) != -1)
		cout << n << endl;
	else
		cout << count(str.begin(), str.end(), '1') << endl;
}
```