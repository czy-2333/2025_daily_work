### [这是最后一次（This Is the Last Time）](https://codeforces.com/contest/2126/problem/D)

**时间限制：** 2 s
**内存限制：** 256 MB

**输入：** 标准输入
**输出：** 标准输出



你有 $n$ 个赌场的访问资格，赌场编号从 $1$ 到 $n$。每个赌场由三个整数描述：$l_i$、$r_i$ 和 $a_i$，满足 $l_i \le a_i \le r_i$。你一开始有 $k$ 枚硬币。

你只有在当前硬币数量 $x$ 满足 $l_i \le x \le r_i$ 时才能进入第 $i$ 个赌场。进入后，你的硬币数会变为 $a_i$。

你可以以**任意顺序访问**这些赌场，且不要求必须访问所有赌场。**每个赌场最多只能访问一次**。

你的任务是找出在最优访问顺序下，最终最多可以获得多少枚硬币。







### 输入

第一行包含一个整数 $t$（$1 \le t \le 10^4$），表示测试用例的数量。

每个测试用例的第一行包含两个整数 $n$ 和 $k$（$1 \le n \le 10^5$，$0 \le k \le 10^9$），表示赌场数量和初始硬币数。

接下来有 $n$ 行，第 $i$ 行包含三个整数 $l_i$、$r_i$ 和 $a_i$（$0 \le l_i \le a_i \le r_i \le 10^9$），描述第 $i$ 个赌场的参数。

保证所有测试用例中 $n$ 的总和不超过 $10^5$。





### 输出

对每个测试用例，输出一个整数代表在最优访问策略下你最终最多能拥有的硬币数。

 



### 样例

**样例输入：**

```
5
3 1
2 3 3
1 2 2
3 10 10
1 0
1 2 2
1 2
1 2 2
2 2
1 3 2
2 4 4
2 5
1 10 5
3 6 5
```



**样例输出：**

```
10
0
2
4
5
```





### 注意

在第一个测试用例中，你可以先去玩第 $2$ 个赌场。之后，你将有 $2$ 枚硬币。接着你可以去玩第 $1$ 个赌场，硬币数会增加到 $3$。最后，玩第 $3$ 个赌场后，你将拥有 $10$ 枚硬币——这是可能获得的最大数量。

在第二个测试用例中，你没有钱，所以无法赚取更多硬币。

在第四个测试用例中，直接去玩第 $2$ 个赌场是有利的，可以赚到 $4$ 枚硬币。





### 题解

可以按 $l$ 从小到大依次遍历所有赌场。

- 若当前硬币数 $t$ 落在第 $i$ 个赌场的访问区间 $[l_i$，$r_i]$ 内：

    要让硬币变多，必须选择那些满足 $t < a_i$ 的赌场。 

    那么是否可以先进入一个让硬币减少的赌场，再通过其他赌场赚回来？

    这种策略不可行。假设进入一个赌场后硬币变为 $a_i$，且 $a_i < t$。考虑之后的赌场 $j$：

    - 若 $a_i < l_j < t < a_j < r_j$，$a_i$ 不满足赌场 $j$ 的进入条件，不能访问；
    - 若 $l_j < a_i < t < a_j < r_j$，则 $t$ 同样满足进入 $j$ 的条件，说明不访问 $i$ 也可以进入 $j$，没必要先变少；
    - 若 $l_j < a_i < a_j < t < r_j$，这些 $t$ 大于 $a_j$ 的情况（还有 $t$ 大于  $r_j$ 等等情况，但和该情况类似，不再列举），进入 $i$ 减少的收益并不能在后续进入 $j$ 带来更多的收益。

    所以，先降后升不会带来更优解，反而可能失去其他的访问资格。

- 如果当前硬币数 $t$ 不在赌场 $i$ 的进入区间 $[l_i$，$r_i]$ 内：

    无论是否先选择某些会减少硬币的赌场，都无法使你后来访问该赌场，因为这样的转换不会带来访问权限的改变。

所以，遵循 "能进入就访问、能变多就更新" 的策略是最优的。若某赌场当前无法访问，则在后续也一定无法访问。



```cpp
void solve()
{
	int n, k;
	cin >> n >> k;
	vector<array<int, 3>> nums(n);

	for (int i = 0; i < n; ++i)
		cin >> nums[i][0] >> nums[i][1] >> nums[i][2];
	sort(nums.begin(), nums.end());

	int ans = k;
	for (int i = 0; i < n; i++)
		if (nums[i][0] <= ans && ans <= nums[i][1])
			ans = max(ans, nums[i][2]);
	cout << ans << endl;
}
```