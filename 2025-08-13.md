## [使其相等（Make it Equal）](https://codeforces.com/contest/2131/problem/C)

**时间限制：** 2 s
**内存限制：** 256 MB



给定两个大小为 $n$ 的 [多重集](https://zh.wikipedia.org/wiki/%E5%A4%9A%E9%87%8D%E9%9B%86)（就当作不用排序的数组） $S$ 和 $T$，以及一个正整数 $k$，你可以对 $S$ 执行以下操作任意次（包括零次）：

-   从 $S$ 中选择一个元素 $x$，并移除 $S$ 中的一个 $x$。然后，将 $x+k$ 或 $|x-k|$ 插入 $S$。

判断是否可能使 $S$ 等于 $T$。如果 **每个元素在 $S$ 和 $T$ 中出现的次数相同**（可理解为 $S$ 和 $T$ 这两个数组排序后相等），则两个多重集 $S$ 和 $T$ 相等。







### 输入

每个测试包含多个测试用例。第一行包含一个整数 $t$（$1 \le t \le 10^4$），测试用例的数量。接下来是各个测试用例的描述。

每个测试用例的第一行包含两个整数 $n$ 和 $k$（$1 \le n \le 2 \cdot 10^5$，$0 \le k \le 10^9$），分别是 $S$ 的大小和给定的常数。

第二行包含 $n$ 个整数 $S_1$，$S_2$，$\ldots$，$S_n$（$0 \le S_i \le 10^9$），$S$ 中的元素。

第三行包含 $n$ 个整数 $T_1$，$T_2$，$\ldots$，$T_n$（$0 \le T_i \le 10^9$），$T$ 中的元素。

保证所有测试用例的 $n$ 的总和不超过 $2 \cdot 10^5$。





### 输出

对于每个测试用例，如果可能使 $S$ 等于 $T$，则输出 $Yes$，否则输出 $No$。

你可以使用任意大小写的形式，如 $yEs$，$yes$，$Yes$ 和 $YES$ 都是可以识别的。





### 样例

**样例输入：**

```cpp
5
1 3
1
2
1 8
4
12
3 5
6 2 9
8 4 11
2 7
2 8
2 9
3 2
0 1 0
1 0 1
```



**样例输出：**

```cpp
YES
YES
YES
NO
NO
```





### 注意

在第一个测试用例中，我们可以从 $S$ 中移除一个 $1$，并向 $S$ 中插入 $|1-k|=|1-3|=2$，从而使 $S$ 等于 $T$。

在第二个测试用例中，我们可以从 $S$ 中移除一个 $4$，并向 $S$ 中插入 $4+k=4+8=12$，从而使 $S$ 等于 $T$。

在最后一个测试用例中，可以证明无法使 $S$ 等于 $T$。

==建议使用 map，使用 unordered_map 可能导致超时！！！==





### 题解

对 $S$ 中任一元素 $x$ 的操作，其模 $k$ 的余数只会在 $x \pmod k$ 和 $(k-x) \pmod k$ 这两个值之间转换。这是因为加减 $k$ 的操作不改变模 $k$ 的余数，而当 $x < k$ 时取绝对值 $|x-k|$ 则会将余数从 $x \pmod k$ 变为 $(k-x) \pmod k$。

因此，一个元素所有可达状态的集合，其 "本质" 完全由这对模 $k$ 的余数 $\{x \pmod k$，$(k-x) \pmod k\}$ 决定。要判断多重集 $S$ 能否转换为 $T$，我们只需验证它们所包含的元素 "本质" 是否一致。

为此，我们可以将每个元素 $x$ 替换为其“本质”的一个范式，即 $\min(x \pmod k$，$(k-x) \pmod k)$。最终的判断方法是：将 $S$ 和 $T$ 中的所有元素都进行这种替换，然后检验两个生成的新多重集是否完全相等。



```cpp
void solve()
{
    int n, k, t;
    cin >> n >> k;
    map<int, int> mp;
    for (int i = 1; i <= 2 * n; ++i)
    {
        cin >> t;
        t = t ? min(t % k, k - (t % k)) : 0;
        mp[t] += i <= n ? +1 : -1;
    }

    bool flag = 1;
    for (auto [_, x]: mp)
        if (x) flag = 0;
    cout << (flag ? "YES" : "NO") << endl;
}
```