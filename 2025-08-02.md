### [位完美（Bitwise Perfect）](https://ac.nowcoder.com/acm/contest/108299/B)

**时间限制：** 2 s
**内存限制：** 512 MB

**输入：** 标准输入
**输出：** 标准输出



军队正在为一场残酷的战争做准备，但事情变得比他们想象的更复杂。队伍中有 $n$ 只军蚁。最初，每只军蚁 $i$（$1 \le i \le n$）的力量为 $a_i$。

然而，在战争期间会发生一些奇怪的事情：一股神秘力量会随机选择一个二元组 $(i$，$j)$（$1 \le i < j \le n$），而选择后，蚂蚁 $i$ 和蚂蚁 $j$ 会消失，并且一只新蚂蚁会替代它们神奇地出现，其力量为 $a_i \oplus a_j$，即 $a_i$ 和 $a_j$ 的按位异或（XOR）。

这种情况非常罕见，在整个战争中 **最多只会发生一次**。

蚂蚁们认为整个队伍的总力量为 $\sum_{i=1}^{n} 2^{a_i}$，如果那件 "奇怪的事" 永远不会减少军队的整体力量，则这个军队被认为是 **位完美** 的。

由于忙于练兵，蚂蚁们没有足够的时间来检查队伍是否位完美。你能帮帮他们吗？可能会有 $t$ 支不同的军队。







### 输入

每组测试包含多个测试用例。第一行包含测试用例的数量 $t$（$1 \le t \le 10^5$）。每个测试用例由两行组成。

第一行包含一个整数 $n$（$2 \le n \le 5 \times 10^5$），表示队伍中蚂蚁的数量。

第二行包含 $n$ 个整数 $a_1$，$a_2$，$\ldots$，$a_n$（$1 \le a_i \le 10^{18}$），表示每只蚂蚁的力量。

保证在单组测试中，$\sum n$ 不会超过 $5 \times 10^5$。




### 输出

对于每个测试用例，如果该军队是位完美的，则输出 "YES"，否则输出 "NO"。你可以以任意大小写打印答案。





### 样例

**样例输入：**

```cpp
3
2
3 5
4
1 2 4 8
3
1 2 3
```



**样例输出：**

```cpp
YES
YES
NO
```





### 注意

在第一个测试用例中，如果两只蚂蚁合并，由于 $3 \oplus 5 = 6$，整个队伍的总力量从 $2^3 + 2^5 = 40$ 变为 $2^6 = 64$，因此该事件不会减少总力量。所以该队伍是位运算完美的。





### 题解

奇怪的事情发生会让 $x$，$y$ 变为 $x \oplus y$，且 $2^x + 2^y \le 2^{x \oplus y}$。该式成立当且仅当 $max(x$，$y) \le x \oplus y$。

假设有 $a$，$b$，$c$ 这三个数，且满足 $a \oplus c \ge a$ 和 $b \oplus c \ge b$。因此我们可以得出，在 $a$ 的最高有效位和 $b$ 的最高有效位上，$c$ 对应的位都必须为 $0$。我们知道，$a \lor b$ 的最高有效位，必然是 $a$ 的最高有效位与 $b$ 的最高有效位中位置更高（即值更大）的那一个。由于 $c$ 在 $a$ 和 $b$ 各自的最高有效位上均为 $0$，那么无论 $a \lor b$ 的最高有效位来自 $a$ 还是 $b$，$c$ 在该位置上的位都必定为 $0$。因为 $c$ 在 $a \lor b$ 的最高有效位上为 $0$，所以根据核心规则 $max(x, y) \le x \oplus y$，可以得到 $c \oplus (a \lor b) \ge a \lor b$ 的结论。

回到题目，要让条件对集合中任意一对元素都成立，就必须保证每个元素的最高有效位，在所有其他元素对应的二进制位上都为 $0$。为了验证这一点，我们可以从大到小遍历所有元素，并维护一个已遍历元素的前缀异或和。对于当前遍历到的元素，如果它与前缀异或和的异或值大于前缀异或和本身，即代表当前元素的最高有效位并未在之前的任何元素中出现过，那么条件暂时成立，并将其更新到前缀异或和中。若所有元素都满足此检验，则整个集合符合题意。

----
上述听不懂直接作废！！！

由于 $10^{18}$ 最多只有 $61$ 个二进制位，$n$ 大于 $61$ 直接输出 "NO"，$n$ 小于 $61$ 暴力遍历每两个元素的组合即可。（测试数据很水）



```cpp
void solve()
{
	int n;
	cin >> n;
	vi nums(n);
	for (int i = 0; i < n; ++i) cin >> nums[i];
	sort(nums.begin(), nums.end(), greater<int>());
	
	for (int i = 1, s = nums[0]; i < n; ++i)
	{
		if ((s ^ nums[i]) < s)
		{
			cout << "No" << endl;
			return;
		}
		s |= nums[i];
	}
	cout << "Yes" << endl;
}
```