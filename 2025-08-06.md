## [拼接回文（Concatenate‌ Palindrome）](https://ac.nowcoder.com/acm/contest/95336/D)

**时间限制：** 2 s
**内存限制：** 256 MB

**输入：** 标准输入
**输出：** 标准输出



Tokitsukaze 有一个长度为 $n$ 的字符串 $a$ 和一个长度为 $m$ 的字符串 $b$，两个字符串均仅包含小写字母。随后，依次进行以下操作：

* 第一步，Tokitsukaze 可以将 $a$ 和 $b$ **重新排列（也可以不进行重新排列）**。
	例如，假设 $a =$ "$xyz$"，对 $a$ 重新排列后，$a$ 可以是：
	"$xyz$"、"$xzy$"、"$yxz$"、"$yzx$"、"$zxy$"、"$zyx$" 这 $6$ 个字符串中的某一个；
* 第二步，Tokitsukaze 可以进行若干次替换（**可以为 $0$ 次**）：每次选一个字符串，再从中选一个位置，然后把该位置上的字母替换成任意小写字母；
* 第三步，将 $a$ 与 $b$ 拼接成形成一个新的字符串 $s$。拼接时为 $a$ 在 $b$ 之前，也就是说 $s = a + b$。

现在，Tokitsukaze 想知道，在第二步操作时，至少需要替换几次，才能使 $s$ 为 <u>回文串</u>$\large^{\text{∗}}$。



$\large^{\text{∗}}$一个字符串被称作回文串，当且仅当这个字符串从左往右读和从右往左读是相同的。例如，"$a$"、"$aa$"、"$aba$"、"$caac$" 均是回文串。







### 输入

每个测试文件中包含多个测试数据。第一行输入一个整数 $t$（$1 \leq t \leq 2 \times 10^5$）表示数据组数，每组测试数据描述如下：

第一行输入两个整数 $n$，$m$（$1 \leq n$，$m \leq 2 \times 10^5$），表示字符串 $a$ 和 $b$ 的长度；

第二行输入一个长度为 $n$ 的字符串 $a$，仅包含小写字母；

第三行输入一个长度为 $m$ 的字符串 $b$，仅包含小写字母。

除此之外，保证单个测试文件的 $n$ 之和不超过 $2 \times 10^5$，$m$ 之和不超过 $2 \times 10^5$。





### 输出

对于每一组测试数据，新起一行。输出一个整数，代表至少需要替换几次，才能使 $s$ 为回文串。





### 样例

**样例输入：**

```cpp
4
2 2
ab
ac
1 3
a
aax
5 2
abcdd
ac
4 4
abcd
xyzw
```



**样例输出：**

```cpp
1
1
0
4
```





### 注意

对于第一组测试数据：

*   第一步，将 $b$ 重新排列，得到 $b' =$ "$ca$";
*   第二步，将字符串 $a$ 的第二个字符替换成 '$c$'，得到 $a' =$ "$ac$";
*   第三步，拼接 $a'$ 和 $b'$ 得到 $s =$ "$acca$"。

我们可以证明，替换次数至少为 $1$ 次。



对于第二组测试数据：

*   第一步，不做任何操作；
*   第二步，将字符串 $a$ 的第一个字符替换为 'x'，得到 $a' =$ "$x$";
*   第三步，拼接 $a'$ 和 $b$ 得到 $s =$ "$xaax$"。

我们可以证明，替换次数至少为 $1$ 次。



对于第三组测试数据：

*   第一步，将 $a$ 重排，得到 $a' =$ "$cadbd$";
*   第二步，不做任何操作；
*   第三步，拼接 $a'$ 和 $b$ 得到 $s =$ "$cadbdac$"。

由于没有进行替换操作，所以答案为 $0$。我们可以证明，替换次数至少为 $0$ 次。





### 题解

由于字符串可重排，问题转化为字符频率匹配。

首先，将字符串 $a$ 与 $b$ 中可配对的字符用于构成回文串 $s$ 的两侧。

然后，将较长字符串（设为 $a$）中剩余的、可自我配对的字符，用于填充回文串的中心部分。此步不消耗替换次数。

若 $n+m$ 为奇数，可额外在最中心放置一个单独的字符。最终，无法配对的字符每两个需要一次替换，因此答案为剩余字符数除以 $2$。



```cpp
void solve()  
{  
    int n, m, t;  
    string a, b;  
    vector<int> nums(26);  
    cin >> n >> m >> a >> b;  
    if (n < m) swap(n, m), swap(a, b);  
    for (char ch: a) ++nums[ch - 'a'];  
    for (char ch: b) --nums[ch - 'a'];  

    int ans = 0;  
    for (int i = 0; i < 26; ++i)  
    {  
        if (n > m && nums[i] > 0)  
            t = 2 * min((n - m) / 2, nums[i] / 2), n -= t, nums[i] -= t;  
        ans += abs(nums[i]);  
    }  
    cout << ans / 2 << endl;  
}
```