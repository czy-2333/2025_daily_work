### [二进制字符串对战（Binary String Battle）](https://codeforces.com/contest/2123/problem/D)

**时间限制：** 2 s
**内存限制：** 256 MB

**输入：** 标准输入
**输出：** 标准输出



Alice 和 Bob 得到一个长度为 $n$ 的二进制字符串 $s$，以及一个整数 $k$（$1 \leq k < n$）。如果 Alice 能将字符串 $s$ 中的所有字符都变为 0，则她获胜。如果 Alice 无法在有限步数内获胜，则 Bob 获胜。

Alice 和 Bob 轮流操作，Alice 先手。

- 在 Alice 的回合，她可以选择字符串 $s$ 中任意一个长度为 $k$ 的**子序列** $^{\large\text{∗}}$，并将该子序列中的所有字符设为 0。
- 在 Bob 的回合，他可以选择字符串 $s$ 中任意一个长度为 $k$ 的**子串** $^{\large\text{† }}$，并将该子串中的所有字符设为 1。

注意，只要在游戏过程中，字符串中所有字符都变为 0（包括在 Alice 和 Bob 的回合之间），Alice 就立即获胜。



$^{\large\text{∗}}$一个字符串的**子序列**是字符串中的一组字符。==注意，这些字符不需要相邻。==

$^{\large\text{† }}$一个字符串的**子串**是字符串中的一组连续字符。==注意，这些字符必须相邻。==

判断在最优策略下谁会获胜。







### 输入

第一行包含一个整数 $t$（$1 \leq t \leq 10^4$）——表示测试用例的数量。

每个测试用例的第一行包含两个整数 $n$ 和 $k$（$2 \leq n \leq 2 \cdot 10^5$，$1 \leq k < n$）。

每个测试用例的第二行包含一个长度为 $n$ 的二进制字符串 $s$。

保证所有测试用例中 $n$ 的总和不超过 $2 \cdot 10^5$。





### 输出

对于每个测试用例，在一行上输出 `“Alice”` 如果 Alice 以最佳策略获胜，输出 `“Bob”` 如果Bob以最佳策略获胜。

您可以以任何大小写输出答案。例如，字符串 `“aLiCe”`，`“alice”`，`“ALICE”` 和 `“alICE”` 将被识别为 `“Alice”`。





### 样例

**样例输入：**

```
6
5 2
11011
7 4
1011011
6 1
010000
4 1
1111
8 3
10110110
6 4
111111
```



**样例输出：**

```
Bob
Alice
Alice
Bob
Bob
Alice
```





### 注意

在第三个样例中，Alice 可以选择由 $s_2$ 构成的子序列，将 $s$ 变为 $000000$，她立即获胜。

在第四个样例中，可以证明 Alice 无法保证在有限步数内将 $s$ 变为 $0000$。





### 题解

当字符串中 `1` 的数量不小于 `k` 时，Alice 无法在第一轮清除所有的 `1`。

她的最优策略是：在每轮选择中，尽可能将剩余的 `1` 向字符串中部“压缩”成稀疏分布，使得 Bob 在选取连续长度为 `k` 的子串时，不容易覆盖到有效的多个 `0`，从而浪费操作。

但如果满足 ${\large\lceil \frac{n}{2} \rceil }\leq k \text{ (} n < 2k )$，即 Bob 每轮操作几乎可以覆盖整个字符串的一半甚至更多，那么在最坏情况下，Bob 可以始终找到一段连续长度为 `k` 的区间来“刷新”至少一个 Alice 尚未处理或刚刚处理完的位置，将 `1` 的总数维持在 `k + 1` 或更多。

这样 Alice 每轮最多清除 `k` 个 `1`，而 Bob 每轮能恢复 `k` 个甚至更具干扰性的 `1`，使得 Alice 永远无法清零，最终 Bob 获胜。



```cpp
void solve()
{
	int n, m, k;
	string str;
	cin >> n >> k;
	cin >> str;
	m = count(str.begin(), str.end(), '1');

	if (m <= k || n < 2 * k)
		cout << "Alice" << endl;
	else
		cout << "Bob" << endl;
}
```

