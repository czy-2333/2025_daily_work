### [生死切割（Slice to Survive）](https://codeforces.com/contest/2109/problem/B)

**时间限制：** 1 s
**内存限制：** 256 MB

**输入：** 标准输入
**输出：** 标准输出



决斗者 Mouf 和 Fouad 来到了一座 $n \times m$ 的竞技场！

Fouad 的怪兽一开始在第 $(a, b)$ 个格子里，行号从 $1$ 到 $n$，列号从 $1$ 到 $m$。

Mouf 和 Fouad 将持续进行战斗，直到整个格子只剩下一个单元格为止。

在每一回合中：

* Mouf 先选择沿某一行或某一列切割整个网格为两部分，**并丢弃不包含 Fouad 怪兽的那一部分**。注意，只有当网格至少还有两个格子时才能进行切割；否则游戏已经结束。
* 然后，在同一回合内，Fouad 可以将他的怪兽移动到当前剩余网格内的任意一个格子（也可以不移动）。

![图示来自第四个测试样例的操作过程](https://espresso.codeforces.com/8b1099cc13f7e0c8fbf449b3e7f2fcd1c9eec0b9.png)

Mouf 想要**最小化回合数**，而 Fouad 想要**最大化回合数**。

若双方都采取最优策略，那么这场史诗对决将持续多少回合？







### 输入

每组测试包含若干个测试用例。

第一行包含一个整数 $t$（$1 \le t \le 10^4$），表示测试用例的数量。

接下来是 $t$ 行，每行四个整数 $n$，$m$，$a$，$b$（$2 \le n$，$m \le 10^9$，$1 \le a \le n$，$1 \le b \le m$），表示网格大小为 $n$ 行 $m$ 列，怪兽初始位置在第 $a$ 行第 $b$ 列。





### 输出

对于每个测试用例，输出一个整数，表示若双方都采取最优策略，这场对决持续的回合数。





### 样例

**样例输入：**

```
8
2 2 1 1
3 3 2 2
2 7 1 4
2 7 2 2
8 9 4 6
9 9 5 5
2 20 2 11
22 99 20 70
```



**样例输出：**

```
2
4
4
3
6
8
6
10
```





### 注意

第1个测试用例，一种可能的操作序列如下：

* 第 1 回合：Mouf 沿水平方向切割第 1 和第 2 行之间的线，保留上半部分（$1 \times 2$ 的网格）。
* Fouad 的怪兽在 $(1$，$1)$。
* 第 2 回合：Mouf 沿垂直方向切掉一列，剩下一个格子，游戏结束。

共用 2 回合。

第 4 个测试用例，一种可能的操作如下：

* 第 1 回合：Mouf 沿垂直方向在第 2 列和第 3 列之间切割，网格分为 $2 \times 2$ 和 $2 \times 5$，丢弃右侧部分，剩下 $2 \times 2$。
* Fouad 把怪兽移动到 $(1$，$1)$。
* 接下来如第一个样例，剩下两步。

共用 3 回合。

你可以参考题目中提供的图示来更直观地理解第四个测试用例的过程。





### 题解

除了第一次切割外，怪物每次都可以选择移动到当前矩形的中心位置，以尽可能减少被切割时的面积损失。因此，从第二次切割开始，每一步至少都能将当前矩形的面积减半。

但第一次切割时，怪物的位置是固定的，因此只能根据其所在位置的上下和左右距离，计算横向或纵向切割所能丢弃的最大区域。我们可以分别模拟第一次选择横向切割和纵向切割的两种情况，计算对应的最少步数，最终取其中的最大值作为答案。



```cpp
void solve()
{
    int n, m, a, b, c, d;
    cin >> n >> m >> a >> d;
    b = m, c = n;
    a = n - max(a - 1, n - a);
    d = m - max(d - 1, m - d);
    int ans1 = 1, ans2 = 1;
    while (a > 1) ++ans1, a = (a + 1) / 2;
    while (b > 1) ++ans1, b = (b + 1) / 2;
    while (c > 1) ++ans2, c = (c + 1) / 2;
    while (d > 1) ++ans2, d = (d + 1) / 2;
    cout << min(ans1, ans2) << endl;
}
```

