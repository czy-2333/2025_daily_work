## [无路可走（Pathless）](https://codeforces.com/contest/2130/problem/B)

**时间限制：** 2 s
**内存限制：** 256 MB



有一个由数值 $0$，$1$，和 $2$ 组成的数组 $a_1$，$a_2$，$\ldots$，$a_n$ 和一个整数 $s$。保证数组 $a_1$，$a_2$，$\ldots$，$a_n$ 中至少包含一个 $0$，一个 $1$ 和一个 $2$。

Alice 想要 **从索引 $1$ 开始**，每次向左或向右移动长度为 $1$ 的一步，并 **最终到达索引** $n$。在移动过程中，Alice 会计算她访问过的位置上数值的总和，她希望这个总和恰好等于 $s$。（翻译为人话就是，你从索引 $1$ 出发，要到达索引 $n$，中途可以来回折返，每访问一个位置都会增加一次该位置的数值，但最终必须达到 $n$，且数值和为 $s$）

形式上，Alice 想要找到一个索引序列 $[i_1$，$i_2$，$\ldots$，$i_m]$，满足以下条件：

-   $i_1 = 1$，$i_m = n$.
-   对于所有的 $1 \le j \le m$，都有 $1 \leq i_j \leq n$。
-   对于所有的 $1 \leq j < m$，都有 $|i_{j} - i_{j+1}| = 1$。
-   $a_{i_1} + a_{i_2} + \ldots + a_{i_m} = s$.

然而，Bob 想要重新排列 $a_1$，$a_2$，$\ldots$，$a_n$ 来阻止 Alice 实现她的目标。请判断是否存在一种重排 $a_1$，$a_2$，$\ldots$，$a_n$ 的方案，使得 Alice 无法找到她想要的目标序列（即使 Alice 足够聪明）。如果存在这样的方案，你还需要输出重排后的数组 $a_1$，$a_2$，$\ldots$，$a_n$。







### 输入

每个测试包含多个测试用例。第一行包含测试用例的数量 $t$（$1 \le t \le 10^3$）。接下来是测试用例的描述。

每个测试用例的第一行包含两个整数 $n$ 和 $s$（$3 \le n \le 50$，$0 \le s \le 1000$）。

每个测试用例的第二行包含 $n$ 个整数 $a_1$，$a_2$，$\ldots$，$a_n$（$0 \le a_i \le 2$）。

保证数组 $a$ 中至少包含一个 $0$，一个 $1$ 和一个 $2$。





### 输出

对于每个测试用例，如果存在一种重排数组 $a$ 的方案使得 Alice 无法找到她的目标序列，则输出 $n$ 个整数，即这样重排后的数组 $a$。否则，输出 $-1$。





### 样例

**样例输入：**

```cpp
6
3 2
0 1 2
3 3
0 1 2
3 6
0 1 2
3 4
0 1 2
3 10
0 1 2
5 1000
2 0 1 1 2
```



**样例输出：**

```cpp
0 1 2
-1
-1
0 2 1 
-1
-1
```





### 注意

在第一个测试用例中，对 $a$ 的任何重排都可以阻止 Alice 实现她的目标。

在第二个测试用例中，无论如何重排 $a$，Alice 总能找到序列 $[1$，$2$，$3]$ 作为她的目标序列。

在第三个测试用例中，不存在任何对 $a$ 的重排可以阻止 Alice 实现她的目标。例如，对于 $a=[0$，$2$，$1]$，Alice 可以找到序列 $[1$，$2$，$3$，$2$，$3]$ 作为她的目标序列。





### 题解

令索引 $1$ 到 $n$ 的最短路径和为 $t = \sum_{i=1}^{n} a_i$。任何更长的路径都包含在相邻位置 $(i$，$i+1)$ 间的往返移动，每次往返会为总和增加 $a_i + a_{i+1}$。因此，所有可行的路径总和可表示为 $t + d$，其中 $d$ 是由往返移动产生的附加和。

若 $s < t$，Alice 无法实现。若 $s = t$，最短路径即满足条件，Bob 无法阻止。

若 $s > t$，Alice 需通过往返移动凑出附加和 $d = s - t$。为阻止 Alice，Bob 必须使 $d$ 无法被凑出。

若数组中存在相邻的 $0$ 和 $1$，往返一次的和为 $1$。利用此操作，Alice 可以凑出任意正整数 $d$，从而总能达成目标。

因此，Bob 必须避免 $0$ 和 $1$ 相邻。此时，任何往返移动的最小附加和来自于和为 $2$（$0$ 与 $2$ 相邻）或 $3$（$1$ 与 $2$ 相邻）的配对。利用这些操作，Alice 可以凑出任意大于等于 $2$ 的整数 $d$。

由此可见，Bob 唯一能阻止 Alice 的机会是当且仅当需要凑出的附加和为 $d=1$。为此，Bob 需重排数组，确保 $0$ 和 $1$ 不相邻。一个可行的排列是先放置所有 $0$，接着是所有 $2$，最后是所有 $1$，如 $[0$，$\dots$，$0$，$2$，$\dots$，$2$，$1$，$\dots$，$1]$。在此排列下，最小的相邻元素和为 $2$，Alice 无法凑出值为 $1$ 的附加和。



```cpp
void solve()  
{  
    int n, m, t;  
    cin >> n >> m;  
    vector<int> nums(3);  
    for (int i = 0; i < n; ++i)  
       cin >> t, nums[t]++;  
    m -= nums[1] + 2 * nums[2];  

    if (m == 0 || m >= 2)  
       cout << -1 << endl;  
    else  
    {  
       while (nums[0]--) cout << 0 << ' ';  
       while (nums[2]--) cout << 2 << ' ';  
       while (nums[1]--) cout << 1 << ' ';  
       cout << endl;  
    }  
}
```