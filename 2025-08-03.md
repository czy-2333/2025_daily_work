### [无路可走（Pathless）](https://codeforces.com/contest/2130/problem/B)

**时间限制：** 2 s
**内存限制：** 256 MB

**输入：** 标准输入
**输出：** 标准输出



有一个由数值 $0$，$1$，和 $2$ 组成的数组 $a_1$，$a_2$，$\ldots$，$a_n$ 和一个整数 $s$。保证数组 $a_1$，$a_2$，$\ldots$，$a_n$ 中至少包含一个 $0$，一个 $1$ 和一个 $2$。

Alice 想要 **从索引 $1$ 开始**，每次向左或向右移动长度为 $1$ 的一步，并 **最终到达索引** $n$。在移动过程中，Alice 会计算她访问过的位置上数值的总和，她希望这个总和恰好等于 $s$。（翻译为人话就是，你从索引 $1$ 出发，要到达索引 $n$，中途可以来回折返，每访问一个位置都会增加一次该位置的数值，但最终必须达到 $n$，且数值和为 $s$）

形式上，Alice 想要找到一个索引序列 $[i_1$，$i_2$，$\ldots$，$i_m]$，满足以下条件：

-   $i_1 = 1$，$i_m = n$.
-   对于所有的 $1 \le j \le m$，都有 $1 \leq i_j \leq n$。
-   对于所有的 $1 \leq j < m$，都有 $|i_{j} - i_{j+1}| = 1$。
-   $a_{i_1} + a_{i_2} + \ldots + a_{i_m} = s$.

然而，Bob 想要重新排列 $a_1$，$a_2$，$\ldots$，$a_n$ 来阻止 Alice 实现她的目标。请判断是否存在一种重排 $a_1$，$a_2$，$\ldots$，$a_n$ 的方案，使得 Alice 无法找到她想要的目标序列（即使 Alice 足够聪明）。如果存在这样的方案，你还需要输出重排后的数组 $a_1$，$a_2$，$\ldots$，$a_n$。







### 输入

每个测试包含多个测试用例。第一行包含测试用例的数量 $t$（$1 \le t \le 10^3$）。接下来是测试用例的描述。

每个测试用例的第一行包含两个整数 $n$ 和 $s$（$3 \le n \le 50$，$0 \le s \le 1000$）。

每个测试用例的第二行包含 $n$ 个整数 $a_1$，$a_2$，$\ldots$，$a_n$（$0 \le a_i \le 2$）。

保证数组 $a$ 中至少包含一个 $0$，一个 $1$ 和一个 $2$。





### 输出

对于每个测试用例，如果存在一种重排数组 $a$ 的方案使得 Alice 无法找到她的目标序列，则输出 $n$ 个整数，即这样重排后的数组 $a$。否则，输出 $-1$。





### 样例

**样例输入：**

```cpp
6
3 2
0 1 2
3 3
0 1 2
3 6
0 1 2
3 4
0 1 2
3 10
0 1 2
5 1000
2 0 1 1 2
```



**样例输出：**

```cpp
0 1 2
-1
-1
0 2 1 
-1
-1
```





### 注意

在第一个测试用例中，对 $a$ 的任何重排都可以阻止 Alice 实现她的目标。

在第二个测试用例中，无论如何重排 $a$，Alice 总能找到序列 $[1$，$2$，$3]$ 作为她的目标序列。

在第三个测试用例中，不存在任何对 $a$ 的重排可以阻止 Alice 实现她的目标。例如，对于 $a=[0$，$2$，$1]$，Alice 可以找到序列 $[1$，$2$，$3$，$2$，$3]$ 作为她的目标序列。





### 题解

明天发！！！



```cpp
void solve()
{
	/*code*/
}
```